# @file ModelFitting.R
#
# Copyright 2021 Observational Health Data Sciences and Informatics
#
# This file is part of CaseControl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Fit the case-control model
#'
#' @details
#' Fits the model using a conditional logistic regression.
#'
#' @param caseControlData        A data frame as generated by the \code{\link{createCaseControlData}}
#'                               function.
#' @param useCovariates          Whether to use the covariates in the \code{caseControlsExposure}.
#' @param excludeCovariateIds    Exclude these covariates from the model.
#' @param includeCovariateIds    Include only these covariates in the model.
#' @param caseControlsExposure   An object of type \code{caseControlsExposure} as created using the
#'                               \code{\link{getDbExposureData}} function.
#' @param prior                  The prior used to fit the model. See
#'                               \code{\link[Cyclops]{createPrior}} for details.
#' @param control                The control object used to control the cross-validation used to
#'                               determine the hyperparameters of the prior (if applicable). See
#'                               \code{\link[Cyclops]{createControl}} for details.
#'
#' @return
#' An object of type \code{outcomeModel}.
#'
#' @export
fitCaseControlModel <- function(caseControlData,
                                useCovariates = FALSE,
                                excludeCovariateIds = c(),
                                includeCovariateIds = c(),
                                caseControlsExposure = NULL,
                                prior = createPrior("laplace", useCrossValidation = TRUE),
                                control = createControl(cvType = "auto",
                                                        startingVariance = 0.01,
                                                        tolerance = 2e-07,
                                                        cvRepetitions = 10,
                                                        selectorType = "byPid",
                                                        noiseLevel = "quiet")) {
  if (useCovariates && is.null(caseControlsExposure))
    stop("Must provide caseControlsExposure when using covariates")
  start <- Sys.time()
  coefficients <- NULL
  treatmentEstimate <- NULL
  logLikelihood <- NA
  fit <- NULL
  status <- "NO MODEL FITTED"
  if (nrow(caseControlData) == 0 || max(caseControlData$exposed) == 0) {
    status <- "NO EXPOSED SUBJECTS"
  } else {
    if (useCovariates) {
      andromeda <- Andromeda::andromeda()
      on.exit(close(andromeda))

      covariates <- caseControlsExposure$covariateData$covariates
      covariates <- covariates %>%
        filter(.data$rowId %in% local(caseControlData$rowId))

      if (length(includeCovariateIds) != 0) {
        covariates <- covariates %>%
          filter(.data$covariateId %in% includeCovariateIds)
      }
      if (length(excludeCovariateIds) != 0) {
        covariates <- covariates %>%
          filter(!.data$covariateId %in% excludeCovariateIds)
      }
      andromeda$covariates <- covariates
      andromeda$covariateRef <- caseControlsExposure$covariateData$covariateRef
      andromeda$analysisRef <- caseControlsExposure$covariateData$analysisRef
      class(andromeda) <- "CovariateData"
      attr(andromeda, "metaData") <- list(populationSize = nrow(caseControlData),
                                          cohortId = -1)
      tidyCovariates <- FeatureExtraction::tidyCovariateData(andromeda)
      on.exit(close(tidyCovariates), add = TRUE)

      treatmentVarId <- 1 + tidyCovariates$covariateRef %>%
        summarise(max(.data$covariateId, na.rm = TRUE)) %>%
        pull()

      prior$exclude <- treatmentVarId  # Exclude treatment variable from regularization

      treatmentCovariate <- tibble(rowId = as.numeric(caseControlData$rowId),
                                   covariateId = rep(treatmentVarId, nrow(caseControlData)),
                                   covariateValue = caseControlData$exposed)
      Andromeda::appendToTable(tidyCovariates$covariates, treatmentCovariate)
      if ("stratumId" %in% names(caseControlData)) {
        modelType <- "clr"
        addIntercept <- FALSE
        tidyCovariates$outcomes <- caseControlData %>%
          select(.data$rowId, .data$stratumId, y = .data$isCase)
        covariates <- tidyCovariates$covariates %>%
          inner_join(select(tidyCovariates$outcomes, .data$rowId, .data$stratumId), by = "rowId")
      } else {
        modelType <- "lr"
        addIntercept <- TRUE
        tidyCovariates$outcomes <- caseControlData %>%
          select(.data$rowId, y = .data$isCase)
        covariates <- tidyCovariates$covariates
      }
      cyclopsData <- Cyclops::convertToCyclopsData(tidyCovariates$outcomes,
                                                   covariates,
                                                   modelType = modelType,
                                                   addIntercept = addIntercept)
    } else {
      prior <- createPrior("none")  # Only one variable, which we're not going to regularize, so effectively no prior
      treatmentVarId <- "exposed"
      if ("stratumId" %in% names(caseControlData)) {
        cyclopsData <- Cyclops::createCyclopsData(isCase ~ exposed,
                                                  data = caseControlData,
                                                  modelType = "lr")
      } else {
        cyclopsData <- Cyclops::createCyclopsData(isCase ~ exposed + strata(stratumId),
                                                  data = caseControlData,
                                                  modelType = "clr")
      }
    }
    fit <- tryCatch({
      Cyclops::fitCyclopsModel(cyclopsData, prior = prior, control = control)
    }, error = function(e) {
      e$message
    })
    if (is.character(fit)) {
      status <- fit
    } else if (fit$return_flag == "ILLCONDITIONED") {
      status <- "ILL CONDITIONED, CANNOT FIT"
    } else if (fit$return_flag == "MAX_ITERATIONS") {
      status <- "REACHED MAXIMUM NUMBER OF ITERATIONS, CANNOT FIT"
    } else {
      status <- "OK"
      coefficients <- coef(fit)
      logRr <- coefficients[names(coefficients) == treatmentVarId]
      ci <- tryCatch({
        confint(fit, parm = treatmentVarId, includePenalty = TRUE)
      }, error = function(e) {
        missing(e)  # suppresses R CMD check note
        c(0, -Inf, Inf)
      })
      if (identical(ci, c(0, -Inf, Inf)))
        status <- "ERROR COMPUTING CI"
      seLogRr <- (ci[3] - ci[2])/(2 * qnorm(0.975))
      llNull <- Cyclops::getCyclopsProfileLogLikelihood(object = fit,
                                                        parm = treatmentVarId,
                                                        x = 0,
                                                        includePenalty = FALSE)$value
      llr <- fit$log_likelihood - llNull
      treatmentEstimate <- data.frame(logRr = logRr,
                                      logLb95 = ci[2],
                                      logUb95 = ci[3],
                                      seLogRr = seLogRr,
                                      llr = llr)
      logLikelihood <- fit$log_likelihood
    }
  }
  outcomeModel <- list()
  outcomeModel$outcomeModelTreatmentEstimate <- treatmentEstimate
  outcomeModel$outcomeModelCoefficients <- coefficients
  outcomeModel$outcomeModelStatus <- status
  outcomeModel$outcomeModelLogLikelihood <- logLikelihood
  if (nrow(caseControlData) == 0) {
    outcomeCounts <- data.frame(cases = 0,
                                controls = 0,
                                exposedCases = 0,
                                exposedControls = 0)
  } else {
    outcomeCounts <- data.frame(cases = sum(caseControlData$isCase),
                                controls = sum(!caseControlData$isCase),
                                exposedCases = sum(caseControlData$isCase & caseControlData$exposed),
                                exposedControls = sum(!caseControlData$isCase &
                                                        caseControlData$exposed))
  }
  outcomeModel$outcomeCounts <- outcomeCounts
  class(outcomeModel) <- "outcomeModel"
  delta <- Sys.time() - start
  ParallelLogger::logInfo(paste("Fitting model took", signif(delta, 3), attr(delta, "units")))
  return(outcomeModel)
}

#' @export
coef.outcomeModel <- function(object, ...) {
  return(object$outcomeModelTreatmentEstimate$logRr)
}

#' @export
confint.outcomeModel <- function(object, parm, level = 0.95, ...) {
  missing(parm)  # suppresses R CMD check note
  if (level != 0.95)
    stop("Only supporting 95% confidence interval")
  return(c(object$outcomeModelTreatmentEstimate$logLb95,
           object$outcomeModelTreatmentEstimate$logUb95))
}

#' @export
print.outcomeModel <- function(x, ...) {
  writeLines("Case-Control fitted model")
  writeLines(paste("Status:", x$outcomeModelStatus))
  writeLines("")
  writeLines("Counts")
  d <- x$outcomeCounts
  colnames(d) <- c("Cases", "Controls", "Exposed cases", "Exposed controls")
  rownames(d) <- "Count"
  printCoefmat(d, P.values = FALSE, has.Pvalue = FALSE)
  writeLines("")
  d <- x$outcomeModelTreatmentEstimate
  output <- data.frame(exp(d$logRr), exp(d$logLb95), exp(d$logUb95), d$logRr, d$seLogRr, d$llr)
  colnames(output) <- c("Estimate", "lower .95", "upper .95", "logRr", "seLogRr", "Log Likelihood Ratio")
  rownames(output) <- "treatment"
  printCoefmat(output)
}
